---
title: Health Probes
description: Configure startup, liveness, and readiness probes
navigation:
  icon: i-lucide-heart-pulse
---

Heimdall uses three health probes to ensure reliable deployments.

## Why Three Probes?

**Startup Probe** (handles first boot):
- Critical for Heimdall because it runs Sequelize migrations on startup
- Migrations can take several minutes on first deploy or after upgrades
- Prevents Kubernetes from killing the pod during migrations
- Allows up to 6 minutes for startup (36 failures × 10s period)

**Liveness Probe** (detects crashes):
- Checks if application is responsive
- Restarts pod if it becomes stuck or deadlocked
- Uses root path `/` since Heimdall lacks dedicated health endpoints

**Readiness Probe** (controls traffic):
- Determines if pod can handle requests
- Removes pod from service endpoints if unhealthy
- Prevents traffic to pods that aren't ready

::note
Heimdall currently doesn't have dedicated health check endpoints. The chart uses the root path `/` which returns HTTP 200 when the application is running.
::

## Default Configuration

The chart includes optimized settings that work well for most deployments:

```yaml
heimdall:
  startupProbe:
    enabled: true
    httpGet:
      path: /
      port: 3000
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 36  # 6 minutes max startup time

  livenessProbe:
    httpGet:
      path: /
      port: 3000
    initialDelaySeconds: 0  # Startup probe handles this
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3

  readinessProbe:
    httpGet:
      path: /
      port: 3000
    initialDelaySeconds: 0  # Startup probe handles this
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
```

## Probe Flow During Deployment

```
Pod Starts
  ↓
Init Container: wait-for-db
  ↓
PostgreSQL Ready?
  ↓ (yes)
Container Starts
  ↓
Startup Probe Begins (check every 10s)
  ↓
App Responding?
  ↓ (after ~30-60s)
Startup Complete
  ↓
Liveness Probe Active (check every 10s)
Readiness Probe Active (check every 10s)
  ↓
Pod Ready for Traffic
```

## Database Initialization

Before Heimdall starts, an init container waits for PostgreSQL:

```yaml
initContainers:
  - name: wait-for-db
    image: postgres:16-alpine
    command:
      - sh
      - -c
      - |
        until pg_isready -h {{ db-host }} -p {{ db-port }} -U {{ db-user }}; do
          echo "Waiting for PostgreSQL..."
          sleep 5
        done
```

This prevents application startup failures due to database unavailability.

## Tuning for Different Scenarios

### Fast Startup (Small Database, Few Migrations)

If your deployment has minimal migrations:

```yaml
heimdall:
  startupProbe:
    enabled: true
    initialDelaySeconds: 5
    periodSeconds: 5
    failureThreshold: 20  # 1.7 minutes max (20 × 5s)
```

### Slow Startup (Large Database, Many Migrations)

For deployments with extensive migrations:

```yaml
heimdall:
  startupProbe:
    enabled: true
    initialDelaySeconds: 30
    periodSeconds: 15
    failureThreshold: 40  # 10 minutes max (40 × 15s)
```

### High Traffic (Aggressive Checks)

For production with heavy load:

```yaml
heimdall:
  livenessProbe:
    periodSeconds: 5  # Check every 5s instead of 10s
    failureThreshold: 2  # Restart faster

  readinessProbe:
    periodSeconds: 3  # Check every 3s
    failureThreshold: 2  # Remove from service faster
```

### Resource-Constrained (Lenient Checks)

For limited resources or shared clusters:

```yaml
heimdall:
  livenessProbe:
    periodSeconds: 20  # Less frequent checks
    timeoutSeconds: 10  # Longer timeout
    failureThreshold: 5  # More tolerant

  readinessProbe:
    periodSeconds: 15
    timeoutSeconds: 10
    failureThreshold: 4
```

## Verification

### Check Probe Status

```bash
kubectl describe pod -n heimdall heimdall-0 | grep -A 10 "Liveness:\|Readiness:\|Startup:"
```

### Check Probe Failures

```bash
kubectl get events -n heimdall --field-selector involvedObject.name=heimdall-0
```

### Monitor Startup

Watch pod startup:
```bash
kubectl get pods -n heimdall -w
```

View init container logs (database wait):
```bash
kubectl logs -n heimdall heimdall-0 -c wait-for-db
```

View application logs:
```bash
kubectl logs -n heimdall heimdall-0 -f
```

Check startup time:
```bash
kubectl get pod -n heimdall heimdall-0 -o jsonpath='{.status.conditions[?(@.type=="Ready")].lastTransitionTime}'
```

## Best Practices

### Development

```yaml
heimdall:
  startupProbe:
    enabled: true
    failureThreshold: 20  # Lenient
```

### Staging

```yaml
heimdall:
  startupProbe:
    enabled: true
    failureThreshold: 36  # Production-like
```

### Production

```yaml
heimdall:
  startupProbe:
    enabled: true
    initialDelaySeconds: 10
    periodSeconds: 10
    failureThreshold: 36

  livenessProbe:
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3

  readinessProbe:
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
```

## Future Improvements

The Heimdall application currently lacks dedicated health check endpoints. The community is working on adding:

- `/health/liveness` - Application running check
- `/health/readiness` - Application + database ready check
- `/health/startup` - Migrations complete check

This will enable more accurate health detection.

## See Also

- [High Availability](/helm-chart/advanced/availability/high-availability) - PDB and HPA
- [Troubleshooting](/helm-chart/advanced/availability/troubleshooting) - Common probe issues
- [Database Configuration](/helm-chart/getting-started/database) - PostgreSQL setup
