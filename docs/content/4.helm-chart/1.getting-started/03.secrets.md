---
title: Secrets Management
description: Three approaches for managing sensitive credentials in the Heimdall Helm chart
navigation:
  icon: i-lucide-key
---

## Overview

The Heimdall Helm chart supports **three distinct approaches** for managing sensitive credentials, designed for different deployment scenarios.

::note{title="Priority Order"}
If multiple approaches are configured: `existingSecret` > `secrets` > `secretsFiles`
::

## Secrets Approaches

::tabs

:::tabs-item{label="Existing Secret (Production)" icon="i-lucide-vault"}

## Existing Secret

::tip{title="Recommended for Production"}
Use this approach with external secret management tools for automated secret injection.
::

### Use Cases

- **External Secrets Operator** (ESO)
- **Sealed Secrets**
- **HashiCorp Vault**
- **Cloud provider secret managers**:
  - AWS Secrets Manager
  - GCP Secret Manager
  - Azure Key Vault

### Configuration

```yaml
heimdall:
  existingSecret: "heimdall-production-secrets"
```

### Required Secret Keys

The external secret must contain these keys:

::field-group
  ::field{name="JWT_SECRET" type="string" required}
  JWT signing secret (128 characters recommended)
  ::
  ::field{name="API_KEY_SECRET" type="string" required}
  API key encryption secret (66 characters recommended)
  ::
  ::field{name="DATABASE_PASSWORD" type="string" required}
  Database password (66 characters recommended)
  ::
  ::field{name="ADMIN_PASSWORD" type="string" required}
  Initial admin user password
  ::
::

### Example: Creating Secret Manually

If not using an external secret manager, create the secret manually:

```bash
kubectl create secret generic heimdall-production-secrets \
  --namespace heimdall \
  --from-literal=JWT_SECRET="$(openssl rand -hex 64)" \
  --from-literal=API_KEY_SECRET="$(openssl rand -hex 33)" \
  --from-literal=DATABASE_PASSWORD="$(openssl rand -hex 33)" \
  --from-literal=ADMIN_PASSWORD="SecurePassword123!"
```

**Verify secret**:

```bash
kubectl get secret heimdall-production-secrets -n heimdall
kubectl describe secret heimdall-production-secrets -n heimdall
```

### Example: External Secrets Operator

Using ESO to sync from AWS Secrets Manager:

```yaml
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: heimdall-secrets
  namespace: heimdall
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: aws-secrets-manager
    kind: ClusterSecretStore
  target:
    name: heimdall-production-secrets
    creationPolicy: Owner
  data:
    - secretKey: JWT_SECRET
      remoteRef:
        key: heimdall/production
        property: jwt_secret
    - secretKey: API_KEY_SECRET
      remoteRef:
        key: heimdall/production
        property: api_key_secret
    - secretKey: DATABASE_PASSWORD
      remoteRef:
        key: heimdall/production
        property: database_password
    - secretKey: ADMIN_PASSWORD
      remoteRef:
        key: heimdall/production
        property: admin_password
```

::warning{title="Create Secret Before Helm Install"}
For production deployments, create secrets **before** running `helm install`. The chart will reference the existing secret instead of creating a new one.
::

:::

:::tabs-item{label="File-based (Development)" icon="i-lucide-file-key"}

## File-based Secrets

::note{title="Default for Local Development"}
This is the **default approach** for local development and testing. Secrets are loaded from gitignored files.
::

### Configuration

```yaml
heimdall:
  secretsFiles: ["env/heimdall-secrets.yaml"]
```

### Generate Secrets

Use the provided script to generate cryptographically secure secrets:

```bash
./generate-heimdall-secrets.sh
```

This creates `heimdall/env/heimdall-secrets.yaml` with:

```yaml
JWT_SECRET: "randomly-generated-128-chars"
API_KEY_SECRET: "randomly-generated-66-chars"
DATABASE_PASSWORD: "randomly-generated-66-chars"
ADMIN_PASSWORD: "Admin_randomly-generated"
```

::warning{title="Automatic Security"}
The secrets file is automatically:
- Added to `.gitignore` (never committed)
- Created with `0600` permissions (owner read/write only)
::

### How It Works

The Helm chart reads the file during template rendering:

```yaml
{{- if .Values.heimdall.secretsFiles }}
  {{- range $path := .Values.heimdall.secretsFiles }}
    {{- $fileContent := $.Files.Get $path }}
    {{- $secrets := $fileContent | fromYaml }}
    {{- range $key, $val := $secrets }}
  {{ $key }}: {{ $val | quote }}
    {{- end }}
  {{- end }}
{{- end }}
```

### Manual Secret File Creation

If you prefer not to use the generation script:

```yaml
# heimdall/env/heimdall-secrets.yaml
JWT_SECRET: "your-128-character-secret-here"
API_KEY_SECRET: "your-66-character-secret-here"
DATABASE_PASSWORD: "your-database-password"
ADMIN_PASSWORD: "your-admin-password"
```

**Set restrictive permissions**:

```bash
chmod 600 heimdall/env/heimdall-secrets.yaml
```

### Gitignore Configuration

The repository includes proper gitignore patterns:

```gitignore
# Secrets files (NEVER commit these)
heimdall/env/heimdall-secrets.yaml
heimdall2/env/heimdall-secrets.yaml

# Template files ARE committed (safe - no secrets)
# heimdall/templates/heimdall-secrets.yaml
```

::caution{title="Never Commit Secrets"}
Always verify that `heimdall/env/heimdall-secrets.yaml` is gitignored before committing.
::

:::

:::tabs-item{label="Inline (CI/CD)" icon="i-lucide-workflow"}

## Inline Secrets

::note{title="Best for CI/CD Pipelines"}
Use this approach for automated deployments where secrets are injected from environment variables or vault CLI.
::

### Configuration

**In values.yaml**:

```yaml
heimdall:
  secrets:
    JWT_SECRET: "your-secret-key-128-chars"
    API_KEY_SECRET: "your-api-key-secret-66-chars"
    DATABASE_PASSWORD: "your-db-password"
    ADMIN_PASSWORD: "your-admin-password"
```

::caution{title="Never Hardcode in Files"}
Do NOT hardcode secrets in values.yaml files committed to git. Use `--set` flags or environment variable substitution.
::

### CI/CD Example (GitHub Actions)

```yaml
name: Deploy Heimdall
on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Deploy to Kubernetes
        env:
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          API_KEY_SECRET: ${{ secrets.API_KEY_SECRET }}
          DATABASE_PASSWORD: ${{ secrets.DATABASE_PASSWORD }}
          ADMIN_PASSWORD: ${{ secrets.ADMIN_PASSWORD }}
        run: |
          helm upgrade --install heimdall ./heimdall \
            --namespace heimdall \
            --create-namespace \
            --set heimdall.secrets.JWT_SECRET="${JWT_SECRET}" \
            --set heimdall.secrets.API_KEY_SECRET="${API_KEY_SECRET}" \
            --set heimdall.secrets.DATABASE_PASSWORD="${DATABASE_PASSWORD}" \
            --set heimdall.secrets.ADMIN_PASSWORD="${ADMIN_PASSWORD}"
```

### CI/CD Example (GitLab CI)

```yaml
deploy:
  stage: deploy
  script:
    - |
      helm upgrade --install heimdall ./heimdall \
        --namespace heimdall \
        --create-namespace \
        --set heimdall.secrets.JWT_SECRET="${JWT_SECRET}" \
        --set heimdall.secrets.API_KEY_SECRET="${API_KEY_SECRET}" \
        --set heimdall.secrets.DATABASE_PASSWORD="${DATABASE_PASSWORD}" \
        --set heimdall.secrets.ADMIN_PASSWORD="${ADMIN_PASSWORD}"
  only:
    - main
```

**GitLab CI Variables**: Store secrets in **Settings** → **CI/CD** → **Variables** with:
- **Protected**: Yes
- **Masked**: Yes
- **Environment scope**: production

### CLI Deployment

```bash
# Read secrets from environment
export JWT_SECRET="$(openssl rand -hex 64)"
export API_KEY_SECRET="$(openssl rand -hex 33)"
export DATABASE_PASSWORD="$(openssl rand -hex 33)"
export ADMIN_PASSWORD="SecurePassword123!"

# Deploy with inline secrets
helm upgrade --install heimdall ./heimdall \
  --namespace heimdall \
  --create-namespace \
  --set heimdall.secrets.JWT_SECRET="${JWT_SECRET}" \
  --set heimdall.secrets.API_KEY_SECRET="${API_KEY_SECRET}" \
  --set heimdall.secrets.DATABASE_PASSWORD="${DATABASE_PASSWORD}" \
  --set heimdall.secrets.ADMIN_PASSWORD="${ADMIN_PASSWORD}"
```

### Vault Integration

Using HashiCorp Vault CLI:

```bash
# Fetch secrets from Vault
export JWT_SECRET="$(vault kv get -field=jwt_secret secret/heimdall/production)"
export API_KEY_SECRET="$(vault kv get -field=api_key_secret secret/heimdall/production)"
export DATABASE_PASSWORD="$(vault kv get -field=database_password secret/heimdall/production)"
export ADMIN_PASSWORD="$(vault kv get -field=admin_password secret/heimdall/production)"

# Deploy
helm upgrade --install heimdall ./heimdall \
  --namespace heimdall \
  --set heimdall.secrets.JWT_SECRET="${JWT_SECRET}" \
  --set heimdall.secrets.API_KEY_SECRET="${API_KEY_SECRET}" \
  --set heimdall.secrets.DATABASE_PASSWORD="${DATABASE_PASSWORD}" \
  --set heimdall.secrets.ADMIN_PASSWORD="${ADMIN_PASSWORD}"
```

::warning{title="Security Considerations"}
- Use masked/protected variables in CI/CD
- Never echo secrets in CI/CD logs
- Rotate secrets regularly
- Use secret scanning tools (GitLeaks, TruffleHog)
::

:::

::

## Security Best Practices

### Secret Generation

Use cryptographically secure random generators:

::code-group

```bash [JWT Secret (128 chars)]
openssl rand -hex 64
```

```bash [API Key Secret (66 chars)]
openssl rand -hex 33
```

```bash [Database Password (66 chars)]
openssl rand -hex 33
```

```bash [All Secrets at Once]
echo "JWT_SECRET: $(openssl rand -hex 64)"
echo "API_KEY_SECRET: $(openssl rand -hex 33)"
echo "DATABASE_PASSWORD: $(openssl rand -hex 33)"
echo "ADMIN_PASSWORD: Admin_$(openssl rand -hex 8)"
```

::

### File Permissions

If using file-based secrets, ensure restrictive permissions:

```bash
# Set read/write for owner only
chmod 600 heimdall/env/heimdall-secrets.yaml

# Verify permissions
ls -la heimdall/env/heimdall-secrets.yaml
# Should show: -rw------- (600)
```

### Secret Rotation

Rotate secrets periodically:

::steps

#### Generate new secrets

```bash
./generate-heimdall-secrets.sh
```

#### Update Kubernetes secret

```bash
kubectl delete secret heimdall-production-secrets -n heimdall
kubectl create secret generic heimdall-production-secrets \
  --from-literal=JWT_SECRET="$(openssl rand -hex 64)" \
  --from-literal=API_KEY_SECRET="$(openssl rand -hex 33)" \
  --from-literal=DATABASE_PASSWORD="$(openssl rand -hex 33)" \
  --from-literal=ADMIN_PASSWORD="NewSecurePassword!"
```

#### Restart Heimdall pods

```bash
kubectl rollout restart statefulset heimdall -n heimdall
```

### Verification

Check secrets are properly configured:

```bash
# Verify secret exists
kubectl get secret -n heimdall | grep heimdall

# Check secret keys (values are redacted)
kubectl describe secret heimdall-production-secrets -n heimdall
```

## Template Implementation

The chart uses `stringData` for cleaner secret handling:

```yaml
{{- if not .Values.heimdall.existingSecret }}
apiVersion: v1
kind: Secret
metadata:
  name: {{ include "heimdall.fullname" . }}-secrets
  namespace: {{ .Release.Namespace }}
type: Opaque
stringData:
  {{- if .Values.heimdall.secrets }}
    {{- range $key, $val := .Values.heimdall.secrets }}
  {{ $key }}: {{ $val | quote }}
    {{- end }}
  {{- else if .Values.heimdall.secretsFiles }}
    {{- range $path := .Values.heimdall.secretsFiles }}
      {{- $fileContent := $.Files.Get $path }}
      {{- $secrets := $fileContent | fromYaml }}
      {{- range $key, $val := $secrets }}
  {{ $key }}: {{ $val | quote }}
      {{- end }}
    {{- end }}
  {{- end }}
{{- end }}
```

::tip{title="Why stringData?"}
Using `stringData` instead of `data` with base64 encoding makes templates more readable and easier to debug. Kubernetes automatically base64-encodes values when the secret is created.
::

## See Also

- [Database Configuration](/helm-chart/getting-started/database) - Configure PostgreSQL connection
- [Environment Variables](/helm-chart/configuration/environment-variables) - Non-sensitive configuration
- [Configuration Validation](/helm-chart/configuration/validation) - OAuth secrets validation
