---
title: Database Migrations
description: How Heimdall handles Sequelize database migrations
navigation:
  icon: i-lucide-database-zap
---

Heimdall runs **Sequelize migrations automatically** on container startup. No separate migration jobs needed.

## How It Works

### Automatic Migrations on Startup

Heimdall's container entrypoint (`cmd.sh`) includes migrations in the startup sequence:

```bash
#!/bin/sh
set -e
yarn backend sequelize-cli db:migrate   # 1. Run migrations
yarn backend sequelize-cli db:seed:all  # 2. Seed database
yarn backend start                      # 3. Start application
```

**What this means:**
- Every pod runs migrations when it starts
- No separate Helm hooks or Jobs needed
- Works identically in Docker, Docker Compose, and Kubernetes
- Migrations complete before application accepts traffic

### Sequelize Safety Features

Sequelize prevents migration problems:

1. **Migration Tracking**: `SequelizeMeta` table records which migrations ran
2. **Idempotent Execution**: Running `db:migrate` multiple times is safe - only new migrations execute
3. **Concurrent Protection**: Database locks prevent race conditions when multiple pods start simultaneously

## Deployment Scenarios

### Single Replica (Default)

Default configuration with one pod:

```yaml
heimdall:
  replicaCount: 1
```

**Startup sequence:**
1. Pod starts
2. Init container (`wait-for-db`) waits for PostgreSQL
3. Container runs `db:migrate`
4. Application starts and becomes ready

### Multiple Replicas (High Availability)

Scaling to multiple pods for HA:

```yaml
heimdall:
  replicaCount: 3
```

**What happens:**
- StatefulSet starts pods sequentially (0, then 1, then 2)
- Each pod runs `db:migrate` on startup
- Sequelize locks prevent race conditions
- Only the first pod applies new migrations
- Other pods skip already-applied migrations

**This is safe.** Sequelize handles concurrent migration attempts correctly.

## Database Permissions

### Embedded PostgreSQL

Using the Bitnami PostgreSQL subchart (default):

```yaml
postgresql:
  enabled: true
```

The `postgres` user has full permissions. No configuration needed.

### External Database

Using AWS RDS, GCP Cloud SQL, or Azure Database:

```yaml
postgresql:
  enabled: false
externalDatabase:
  host: db.example.com
  database: heimdall_production
  username: heimdall_app
```

**Required permissions:**

Database user needs DDL permissions to create, alter, and drop tables:

```sql
-- Grant migration permissions
GRANT CREATE, ALTER, DROP ON DATABASE heimdall_production TO heimdall_app;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO heimdall_app;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO heimdall_app;
```

::warning
If database user has read-only permissions, migrations fail on startup and pods crash.
::

## Troubleshooting

### Pod Crashes on Startup

**Symptom:** Pod stuck in `CrashLoopBackOff`, logs show migration failures

**Common causes:**

**1. Database not ready**

Init container should prevent this, but network issues can occur.

```bash
# Check init container logs
kubectl logs -n heimdall <pod-name> -c wait-for-db
```

**2. Insufficient permissions**

External database user lacks DDL permissions.

```bash
# Check migration errors
kubectl logs -n heimdall <pod-name> | grep "db:migrate"
```

**3. Network connectivity**

Pod can't reach database host.

```bash
# Test connectivity
kubectl exec -n heimdall <pod-name> -- pg_isready -h <db-host> -p 5432
```

**Fix:** Resolve the underlying issue (database access, credentials, networking). Pod auto-restarts and retries migrations.

---

### Migrations Take Too Long

**Symptom:** Pods take several minutes to become Ready

**Causes:**
- Large database with many existing rows
- Complex migrations (adding indexes to millions of rows)
- Slow database performance

**Solution 1: Increase startup probe timeout**

```yaml
heimdall:
  startupProbe:
    initialDelaySeconds: 60
    periodSeconds: 10
    failureThreshold: 30  # Allows 5 minutes for startup
```

**Solution 2: Pre-run migrations manually** (advanced)

```bash
# Create temporary migration pod
kubectl run heimdall-migrate -n heimdall \
  --image=mitre/heimdall2:release-latest \
  --restart=Never \
  --env="DATABASE_HOST=heimdall-postgresql" \
  --env="DATABASE_PASSWORD=<password>" \
  --command -- yarn backend sequelize-cli db:migrate

# Wait for completion
kubectl wait --for=condition=complete -n heimdall pod/heimdall-migrate --timeout=600s

# Migrations complete - deploy application
helm upgrade heimdall ./heimdall -n heimdall
```

## Helm Upgrade Behavior

**What happens during a Helm upgrade?**

StatefulSet updates pods sequentially:

1. Helm triggers upgrade
2. Pod 0 terminates gracefully
3. New Pod 0 starts:
   - Init container waits for database
   - Container runs `db:migrate` (applies new migrations if any)
   - Application starts
4. Process repeats for Pod 1, Pod 2, etc.

**This ensures:**
- Migrations run before new application code starts
- Only one pod updates at a time (StatefulSet sequential updates)
- Sequelize prevents duplicate migration execution

## Architecture Decision

### Why No Separate Migration Job?

Heimdall **does not use a separate Helm hook Job** for migrations, unlike some charts (GitLab, Vulcan).

**Reasons:**

1. **Application design**: Heimdall's container entrypoint (`cmd.sh`) includes migrations
2. **Ecosystem pattern**: Node.js/Sequelize apps (Ghost, Directus, Strapi) use this pattern
3. **Simplicity**: No extra Kubernetes objects (Jobs, ServiceAccounts, hooks)
4. **Idempotency**: Sequelize migration tracking makes multiple executions safe
5. **Consistency**: Works identically in Docker Compose and Kubernetes

**When would a separate job make sense?**

Separate migration jobs are beneficial when:
- Application does NOT run migrations on startup (e.g., Rails `rails server` just starts the server)
- Strict ordering required (e.g., backup → migrate → deploy with hook weights)
- Manual approval needed (e.g., review migration SQL before applying)

None of these apply to Heimdall.

### Comparison: Heimdall vs Vulcan

**Heimdall (Application-Managed):**

::steps

### Helm Install/Upgrade

Helm triggers deployment.

### Pod Starts

StatefulSet creates pod.

### Init: Wait for DB

Init container verifies PostgreSQL is ready.

### Run: db:migrate

Container runs Sequelize migrations.

### Run: db:seed

Container seeds database (if configured).

### Start Application

Application starts and accepts traffic.

::

**Pros:** Simple, consistent, self-healing
**Cons:** No explicit migration approval step

---

**Vulcan (Separate Job):**

::steps

### Helm Install/Upgrade

Helm triggers deployment.

### Migration Job Runs

Separate Kubernetes Job executes.

### Job: rails db:migrate

Job runs Rails migrations.

### Pod Starts

StatefulSet creates application pod.

### Init: Wait for DB

Init container verifies PostgreSQL is ready.

### Start Application

Application starts and accepts traffic.

::

**Pros:** Explicit migration step, easier to troubleshoot separately
**Cons:** More complex (Job + hooks), requires careful ordering

---

## Summary

Heimdall runs migrations automatically on container startup:
- **Automatic:** No manual steps or separate jobs needed
- **Safe:** Sequelize idempotency and locking prevent issues with multiple replicas
- **Consistent:** Identical behavior in Docker, Docker Compose, and Kubernetes
- **Self-healing:** Fix database issues, pod auto-restarts with migrations

**References:**
- [Heimdall Source Code](https://github.com/mitre/heimdall2) - See `cmd.sh` for startup sequence
- [Sequelize Migrations](https://sequelize.org/docs/v6/other-topics/migrations/) - Official documentation
