## Please see the following for explanations on many of the Heimdall specific envvars:
# https://github.com/mitre/heimdall2/wiki/Environment-Variables-Configuration
# apps/backend/.env-example

# classificationBannerText: default is no banner
# classificationBannerTextColor: default white
# classificationBannerColor: default red

nodeEnv: production

# adminEmail: default admin@heimdall.local
# adminUsesExternalAuth: default false
# adminPassword: default autogenerated (CHECK THE LOGS TO FIND IT)

# localLoginDisabled: default false
# registrationDisabled: default false
# oneSessionPerUser: default false
## Generate the following via `openssl rand -hex 64` and set
# jwtSecret: long-random-string-of-text
## Set `1d` or `25m`
# jwtExpireTime: 25m

## Generate the following via `openssl rand -hex 33` and set
# apiKeySecret: different-long-random-string-of-text
# maxFileUploadSize: size-in-megabytes (default 50)

## Set FDQN for external database host or set `postgresql.enabled` equal to `true`
# databaseHost: postgresql.example.com
## Set external database port or set `postgresql.enabled` equal to `true`
# databasePort: 5672
databaseName: heimdall-database
databaseUsername: postgres
## Set postgres user's password via `openssl rand -hex 33`
# databasePassword: long-random-string-of-text
# databaseSsl: default false
# databaseSslInsecure: default false
# databaseSslKey: path-or-raw-key # Must be set if using SSL
# databaseSslCert: path-or-raw-cert # Must be set if using SSL
# databaseSslCa: path-or-raw-ca # Must be set if using SSL

# externalUrl: 'public'/externally facing URL for your deployment (ex. for use in callback urls for auth integrations) # Must be set

# splunkHostUrl: default empty string (ex. https://your.splunk.domain.com)
# tenableHostUrl: default empty string (ex. https://your.tenable.domain.com)
# forceTenableFrontend: default false (If true, the frontend will use Tenable.SC Lite features

# ldapEnabled: default false
# ldapHost: url # Must be set if using LDAP 
# ldapPort: default 389
# ldapBindDn: Dn of user used for lookups # Must be set if using LDAP
# ldapPassword: user's password # Must be set if using LDAP
# ldapSearchBase: ex. "OU=Users, DC=<yourdomain>, DC=local" # Must be set if using LDAP 
# ldapSearchFilter: ex. "sAMAccountName={{username}}"  
# ldapNameField: default name
# ldapMailField: default mail
# ldapSsl: default false
# ldapSslInsecure: default false
# ldapSslCa: path-or-raw-ca

# googleClientId: value-from-google # Must be set if using Google login
# googleClientSecret: value-from-google # Must be set if using Google login

# githubClientId: value-from-github # Must be set if using GitHub login
# githubClientSecret: value-from-github # Must be set if using GitHub login
# githubEnterpriseInstanceBaseUrl: default https://github.com/
# githubEnterpriseInstanceApiUrl: default https://api.github.com/

# gitlabClientId: value-from-gitlab # Must be set if using GitLab login
# gitlabClientSecret: value-from-gitlab # Must be set if using GitLab login
# gitlabBaseUrl: default https://gitlab.com/

# httpsProxy: # example http://my.proxy.com:8000. (No default)

# oktaDomain: yourdomain.okta.com # Your assigned Okta domain (No default, if using Okta login either this variable or OKTA_ISSUER, OKTA_AUTHORIZATION_URL, OKTA_TOKEN_URL, and OKTA_USER_INFO_URL must be set)
# oktaClientId: value-from-okta # No default, must be set if using Okta login
# oktaClientSecret: value-from-okta # Your application's client secret (No default, must be set if using Okta login)
# oktaIssuer: okta-base-url # example: https://domain.octa.com No default, if using Okta login either OKTA_AUTHORIZATION_URL, OKTA_TOKEN_URL, OKTA_USER_INFO_URL, and this variable or OKTA_DOMAIN must be set
# oktaAuthorizationUrl: okta-authorization-endpoint # example: https://domain.octa.com/oauth2/v1/authorize No default, if using Okta login either OKTA_ISSUER, OKTA_TOKEN_URL, OKTA_USER_INFO_URL, and this variable or OKTA_DOMAIN must be set
# oktaTokenUrl: okta-token-endpoint # No default, if using Okta login either OKTA_ISSUER, OKTA_AUTHORIZATION_URL, OKTA_USER_INFO_URL, and this variable or OKTA_DOMAIN must be set
# oktaUserInfoUrl: value-from-okta # No default, if using Okta login either OKTA_ISSUER, OKTA_AUTHORIZATION_URL, OKTA_TOKEN_URL, and this variable or OKTA_DOMAIN must be set
# oktaUseHttpsProxy: # Default false, requires the `HTTPS_PROXY` envvar also being set

# oidcName: frontend-name # No default, must be set if using OIDC login
# oidcIssuer: base-url # example: https://sample.us.auth0.com No default, must be set if using OIDC login
# oidcAuthorizationUrl: auth-endpoint # example: https://sample.us.auth0.com/authorize No default, must be set if using OIDC login
# oidcTokenUrl: token-endpoint # example: https://sample.us.auth0.com/oauth/token No default, must be set if using OIDC login
# oidcUserInfoUrl: info-endpoint # example: https://sample.us.auth0.com/userinfo No default, must be set if using OIDC login
# oidcUsesVerifiedEmail: # Default is set to 'true', must be set to 'false' if email verification is not required
# oidcClientId: value-from-oidc # No default, must be set if using OIDC login
# oidcClientSecret: value-from-oidc # No default, must be set if using OIDC login
# oidcExternalGroups: # Default false
# oidcUsesPKCES256: # Default false, must be set if using PKCE, must not be set if you want to use the plain code challenge method
# oidcUsesPKCEPlain: # Default false, must be set if using PKCE, must not be set if you want to use the S256 code challenge method
# oidcUseHttpsProxy: # Default false, requires the HTTPS_PROXY envvar also being set

# In order to use sops, set enable to true, make sure the name of the external secret is the same as the internal secret, default: heimdall2
sops:
  enabled: false
  secrets: []
    # Populate this array with with all secrets you want encrypted in the SOPS pod
    # Example
    # - DATABASE_PASSWORD
    # - DATABASE_USERNAME
    # - ADMIN_PASSWORD
    # - JWT_SECRET
    # - API_KEY_SECRET

# ===========================================================================
# PostgreSQL Database (Bitnami Subchart)
# ===========================================================================
# Deploy PostgreSQL using Bitnami subchart or use external database
# Set postgresql.enabled=false to use external database (see externalDatabase below)
postgresql:
  # -- Deploy PostgreSQL using Bitnami subchart (set false to use external database)
  enabled: true

  ## Image configuration
  image:
    # -- PostgreSQL image tag (Bitnami uses 'latest' for free tier)
    tag: "latest"

  ## Authentication parameters
  auth:
    # -- PostgreSQL database name
    database: heimdall
    # -- PostgreSQL username (default: postgres)
    username: postgres
    # -- PostgreSQL password (leave empty for auto-generated, recommended)
    # To retrieve auto-generated password: kubectl get secret -n <namespace> <release>-postgresql -o jsonpath="{.data.postgres-password}" | base64 -d
    # Note: Do NOT use existingSecret - it has known issues with Bitnami chart
    password: ""

  ## Primary database configuration
  primary:
    ## Service configuration
    service:
      # -- PostgreSQL service port
      ports:
        postgresql: 5432

    ## Persistence configuration
    persistence:
      # -- Enable persistent storage for PostgreSQL data
      enabled: true
      # -- Size of persistent volume claim
      size: 10Gi
      # -- Storage class for PVC (leave empty for default)
      storageClass: ""

    ## Resource limits and requests
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 200m
        memory: 256Mi

# ===========================================================================
# External Database Configuration
# ===========================================================================
# Use when postgresql.enabled=false
# Supports AWS RDS, Google Cloud SQL, Azure Database, or self-hosted PostgreSQL
externalDatabase:
  # -- External PostgreSQL hostname (e.g., heimdall-db.abc123.us-east-1.rds.amazonaws.com)
  host: ""
  # -- External PostgreSQL port
  port: 5432
  # -- External database name
  database: heimdall
  # -- External database username
  username: postgres
  # -- Existing secret containing database password
  # Secret must have key matching existingSecretPasswordKey
  existingSecret: ""
  # -- Key in existingSecret that contains the password
  existingSecretPasswordKey: "password" 

# ===========================================================================
# Custom CA Certificates (Optional)
# ===========================================================================
# For corporate MITM proxies, internal APIs with custom CA, private registries
#
# How it works:
#   1. Certificates stored in ConfigMap (individual .crt or .pem files)
#   2. Init container concatenates all certificates into single ca-bundle.pem
#   3. NODE_EXTRA_CA_CERTS points to the concatenated bundle file
#
# This approach supports multiple certificates while working with Node.js's
# requirement that NODE_EXTRA_CA_CERTS must point to a single file.
extraCertificates:
  # -- Enable custom CA certificate injection
  enabled: false

  # -- Name of existing ConfigMap containing CA certificates (.crt or .pem files)
  # The ConfigMap should be created in the same namespace as Heimdall
  # Example: kubectl create configmap custom-ca-certs --from-file=mitre-ca.crt -n heimdall
  # All certificates will be concatenated into a single bundle file at runtime
  configMapName: ""

  # -- Or provide certificates directly (chart will create ConfigMap)
  # Supports multiple certificates with any filename (.crt or .pem extensions)
  # All certificates will be automatically concatenated into ca-bundle.pem
  certificates: {}
    # Example:
    # mitre-ca.crt: |
    #   -----BEGIN CERTIFICATE-----
    #   MIIDXTCCAkWgAwIBAgIJAKJ...
    #   -----END CERTIFICATE-----
    # dod-root.crt: |
    #   -----BEGIN CERTIFICATE-----
    #   MIIEFzCCAv+gAwIBAgIQB/L...
    #   -----END CERTIFICATE-----
    # corporate-intermediate.pem: |
    #   -----BEGIN CERTIFICATE-----
    #   MIIEFzCCAv+gAwIBAgIQB/L...
    #   -----END CERTIFICATE----- 

heimdall:
  image:
    repository: heimdall-app
    pullPolicy: IfNotPresent
    tag: "arm64-test"

  # ===========================================================================
  # Secrets Management (Three Approaches - Following Vulcan Pattern)
  # ===========================================================================
  # Priority: existingSecret > secrets > secretsFiles
  #
  # Approach 1: Use existing secret (Production - Recommended)
  # Use with External Secrets Operator, Sealed Secrets, or Vault
  # Example:
  #   existingSecret: "heimdall-production-secrets"
  # Required secret keys: JWT_SECRET, DATABASE_PASSWORD, ADMIN_PASSWORD
  existingSecret: ""

  # Approach 2: File-based secrets (Development - Default)
  # Loads secrets from local files (gitignored)
  # Generate with: ./generate-heimdall-secrets.sh
  # Example:
  #   secretsFiles: ["env/heimdall-secrets.yaml"]
  secretsFiles: ["env/heimdall-secrets.yaml"]

  # Approach 3: Inline secrets (CI/CD)
  # Provide secrets directly in values (use --set or environment variables)
  # Example:
  #   secrets:
  #     JWT_SECRET: "your-secret-key-128-chars"
  #     DATABASE_PASSWORD: "your-db-password"
  #     ADMIN_PASSWORD: "your-admin-password"
  secrets: {}

  # Secret resource name (only used if existingSecret is not set)
  secret:
    name: heimdall-secrets

  # ===========================================================================
  # Environment Configuration Overrides (Optional)
  # ===========================================================================
  # Override non-sensitive environment variables from env/heimdallconfig.yaml
  # Example:
  #   config:
  #     NODE_ENV: "production"
  #     MAX_FILE_UPLOAD_SIZE: "100"
  #     CLASSIFICATION_BANNER_TEXT: "UNCLASSIFIED"
  #     LDAP_ENABLED: "true"
  #     LDAP_HOST: "ldap.example.com"
  config: {}

  # ConfigMap resource name
  configmap:
    name: heimdall-config

  # ===========================================================================
  # Service Account
  # ===========================================================================
  # Service account for Heimdall pods
  serviceAccount:
    # Create service account for Heimdall pods
    create: true
    # Annotations for service account (e.g., for AWS IAM roles, GCP Workload Identity)
    annotations: {}
    # Example for AWS EKS:
    # annotations:
    #   eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/heimdall-role
    # Name of service account (generated if empty)
    name: ""

  # ===========================================================================
  # Database Migrations
  # ===========================================================================
  # Heimdall runs Sequelize migrations automatically on container startup
  # via the cmd.sh entrypoint script. No separate migration job is needed.
  #
  # Migration sequence (every pod startup):
  #   1. Init container waits for PostgreSQL (pg_isready)
  #   2. Container runs: yarn backend sequelize-cli db:migrate
  #   3. Container runs: yarn backend sequelize-cli db:seed:all
  #   4. Application starts: yarn backend start
  #
  # Sequelize tracks applied migrations in the SequelizeMeta table, making
  # migrations idempotent and safe to run on every pod startup.
  #
  # For more details, see: docs/content/4.helm-chart/database-migrations.md

  service:
    type: ClusterIP
    port: 3000

  ingress:
    # -- Enable ingress controller resource (disabled by default, enable for production)
    enabled: false

    # -- Ingress class name (traefik, nginx, kong, etc.)
    # Traefik is the recommended default (Nginx will be retired March 2026)
    className: "traefik"

    # -- Custom annotations (controller-specific)
    annotations: {}
      # Examples for Traefik:
      # traefik.ingress.kubernetes.io/router.entrypoints: websecure
      # traefik.ingress.kubernetes.io/router.tls: "true"
      # cert-manager.io/cluster-issuer: "letsencrypt-prod"
      #
      # Examples for Nginx:
      # nginx.ingress.kubernetes.io/proxy-body-size: "100m"
      # nginx.ingress.kubernetes.io/ssl-redirect: "true"
      # cert-manager.io/cluster-issuer: "letsencrypt-prod"

    # -- Ingress hosts with paths
    hosts:
      - host: heimdall.local
        paths:
          - path: /
            pathType: Prefix

    # -- TLS configuration for ingress
    tls: []
      # - secretName: heimdall-tls
      #   hosts:
      #     - heimdall.example.com
  
# Introducing this tag utilizes the gateway API instead of the ingress API.
# Both cannot be used at the same time.
  gateway:
    enabled: false
#    apiVersion: 
#    kind: VirtualService 
    
#    gateways:
#       List of gateways
#      hosts:
#         List of hostsnames that the gateway handles traffic for
#        - 
#      http: Route Config
#        - name: Name for the route group
#          route: 
#            - destination:
#                host: Service name within cluster
#                port: Port number of service
#                  number: 3000
#    annotations:
#       Optional annotations for the gateway

  podAnnotations: {}
#   Example:
#     imageregistry: "https://example.docker.com"

  podSecurityContext: {}
#   Example:
#     runAsUser: 1000
#     runAsGroup: 3000

  securityContext: {}
#   Example:
#    runAsUser: 1000
#    runAsGroup: 3000

  resources: {}
#    Example:
#    requests:
#      cpu: 100m
#      memory: 128Mi
#    limits:
#      cpu: 200m
#      memory: 256Mi

  nodeSelector: {}
#    Example:
#    kubernetes.io/example: linux
#    kubernetes.io/example: amd64

  tolerations: []
#    Example:
#    - key: "node-role.kubernetes.io/example"
#      operator: "Exists"
#      effect: "NoSchedule"

  affinity: {}

  # ===========================================================================
  # Health Probes
  # ===========================================================================
  # Startup probe: Handles slow initial startup (database migrations)
  # Liveness probe: Detects if application is stuck/deadlocked
  # Readiness probe: Determines if pod can receive traffic

  startupProbe:
    enabled: true
    httpGet:
      path: /
      port: 3000
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    # Allow up to 6 minutes for startup (36 checks * 10s = 360s)
    # Heimdall runs Sequelize migrations on startup which can take time
    failureThreshold: 36

  livenessProbe:
    httpGet:
      path: /
      port: 3000
    initialDelaySeconds: 0  # Startup probe handles initial delay
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3

  readinessProbe:
    httpGet:
      path: /
      port: 3000
    initialDelaySeconds: 0  # Startup probe handles initial delay
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3

  # ===========================================================================
  # PodDisruptionBudget (High Availability)
  # ===========================================================================
  # Prevents disruptions during voluntary events (node drains, upgrades)
  # Only relevant when running multiple replicas (replicaCount > 1)
  podDisruptionBudget:
    enabled: false
    # Ensure at least 1 pod is available during disruptions
    minAvailable: 1
    # Or use maxUnavailable instead (cannot use both)
    # maxUnavailable: 1

  # ===========================================================================
  # HorizontalPodAutoscaler (Auto-scaling)
  # ===========================================================================
  # Automatically scales pods based on CPU/memory usage
  # Requires metrics-server to be installed in the cluster
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 3
    targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80

  imagePullSecrets: []
#     - name: your-secret-name
