## Please see the following for explanations on many of the Heimdall specific envvars:
# https://github.com/mitre/heimdall2/wiki/Environment-Variables-Configuration
# apps/backend/.env-example

# classificationBannerText: default is no banner
# classificationBannerTextColor: default white
# classificationBannerColor: default red

nodeEnv: production

# adminEmail: default admin@heimdall.local
# adminUsesExternalAuth: default false
# adminPassword: default autogenerated (CHECK THE LOGS TO FIND IT)

# localLoginDisabled: default false
# registrationDisabled: default false
# oneSessionPerUser: default false
## Generate the following via `openssl rand -hex 64` and set
# jwtSecret: long-random-string-of-text
## Set `1d` or `25m`
# jwtExpireTime: 25m

## Generate the following via `openssl rand -hex 33` and set
# apiKeySecret: different-long-random-string-of-text
# maxFileUploadSize: size-in-megabytes (default 50)

## Set FDQN for external database host or set `postgresql.enabled` equal to `true`
# databaseHost: postgresql.example.com
## Set external database port or set `postgresql.enabled` equal to `true`
# databasePort: 5672
databaseName: heimdall-database
databaseUsername: postgres
## Set postgres user's password via `openssl rand -hex 33`
# databasePassword: long-random-string-of-text
# databaseSsl: default false
# databaseSslInsecure: default false
# databaseSslKey: path-or-raw-key # Must be set if using SSL
# databaseSslCert: path-or-raw-cert # Must be set if using SSL
# databaseSslCa: path-or-raw-ca # Must be set if using SSL

# externalUrl: 'public'/externally facing URL for your deployment (ex. for use in callback urls for auth integrations) # Must be set

# splunkHostUrl: default empty string (ex. https://your.splunk.domain.com)
# tenableHostUrl: default empty string (ex. https://your.tenable.domain.com)
# forceTenableFrontend: default false (If true, the frontend will use Tenable.SC Lite features

# ldapEnabled: default false
# ldapHost: url # Must be set if using LDAP 
# ldapPort: default 389
# ldapBindDn: Dn of user used for lookups # Must be set if using LDAP
# ldapPassword: user's password # Must be set if using LDAP
# ldapSearchBase: ex. "OU=Users, DC=<yourdomain>, DC=local" # Must be set if using LDAP 
# ldapSearchFilter: ex. "sAMAccountName={{username}}"  
# ldapNameField: default name
# ldapMailField: default mail
# ldapSsl: default false
# ldapSslInsecure: default false
# ldapSslCa: path-or-raw-ca

# googleClientId: value-from-google # Must be set if using Google login
# googleClientSecret: value-from-google # Must be set if using Google login

# githubClientId: value-from-github # Must be set if using GitHub login
# githubClientSecret: value-from-github # Must be set if using GitHub login
# githubEnterpriseInstanceBaseUrl: default https://github.com/
# githubEnterpriseInstanceApiUrl: default https://api.github.com/

# gitlabClientId: value-from-gitlab # Must be set if using GitLab login
# gitlabClientSecret: value-from-gitlab # Must be set if using GitLab login
# gitlabBaseUrl: default https://gitlab.com/

# httpsProxy: # example http://my.proxy.com:8000. (No default)

# oktaDomain: yourdomain.okta.com # Your assigned Okta domain (No default, if using Okta login either this variable or OKTA_ISSUER, OKTA_AUTHORIZATION_URL, OKTA_TOKEN_URL, and OKTA_USER_INFO_URL must be set)
# oktaClientId: value-from-okta # No default, must be set if using Okta login
# oktaClientSecret: value-from-okta # Your application's client secret (No default, must be set if using Okta login)
# oktaIssuer: okta-base-url # example: https://domain.octa.com No default, if using Okta login either OKTA_AUTHORIZATION_URL, OKTA_TOKEN_URL, OKTA_USER_INFO_URL, and this variable or OKTA_DOMAIN must be set
# oktaAuthorizationUrl: okta-authorization-endpoint # example: https://domain.octa.com/oauth2/v1/authorize No default, if using Okta login either OKTA_ISSUER, OKTA_TOKEN_URL, OKTA_USER_INFO_URL, and this variable or OKTA_DOMAIN must be set
# oktaTokenUrl: okta-token-endpoint # No default, if using Okta login either OKTA_ISSUER, OKTA_AUTHORIZATION_URL, OKTA_USER_INFO_URL, and this variable or OKTA_DOMAIN must be set
# oktaUserInfoUrl: value-from-okta # No default, if using Okta login either OKTA_ISSUER, OKTA_AUTHORIZATION_URL, OKTA_TOKEN_URL, and this variable or OKTA_DOMAIN must be set
# oktaUseHttpsProxy: # Default false, requires the `HTTPS_PROXY` envvar also being set

# oidcName: frontend-name # No default, must be set if using OIDC login
# oidcIssuer: base-url # example: https://sample.us.auth0.com No default, must be set if using OIDC login
# oidcAuthorizationUrl: auth-endpoint # example: https://sample.us.auth0.com/authorize No default, must be set if using OIDC login
# oidcTokenUrl: token-endpoint # example: https://sample.us.auth0.com/oauth/token No default, must be set if using OIDC login
# oidcUserInfoUrl: info-endpoint # example: https://sample.us.auth0.com/userinfo No default, must be set if using OIDC login
# oidcUsesVerifiedEmail: # Default is set to 'true', must be set to 'false' if email verification is not required
# oidcClientId: value-from-oidc # No default, must be set if using OIDC login
# oidcClientSecret: value-from-oidc # No default, must be set if using OIDC login
# oidcExternalGroups: # Default false
# oidcUsesPKCES256: # Default false, must be set if using PKCE, must not be set if you want to use the plain code challenge method
# oidcUsesPKCEPlain: # Default false, must be set if using PKCE, must not be set if you want to use the S256 code challenge method
# oidcUseHttpsProxy: # Default false, requires the HTTPS_PROXY envvar also being set

# In order to use sops, set enable to true, make sure the name of the external secret is the same as the internal secret, default: heimdall2
sops:
  enabled: false
  secrets: []
    # Populate this array with with all secrets you want encrypted in the SOPS pod
    # Example
    # - DATABASE_PASSWORD
    # - DATABASE_USERNAME
    # - ADMIN_PASSWORD
    # - JWT_SECRET
    # - API_KEY_SECRET

# ===========================================================================
# PostgreSQL Database (Bitnami Subchart)
# ===========================================================================
# Deploy PostgreSQL using Bitnami subchart or use external database
# Set postgresql.enabled=false to use external database (see externalDatabase below)
postgresql:
  # -- Deploy PostgreSQL using Bitnami subchart (set false to use external database)
  enabled: true

  ## Image configuration
  image:
    # -- PostgreSQL image tag (Bitnami uses 'latest' for free tier)
    tag: "latest"

  ## Authentication parameters
  auth:
    # -- PostgreSQL database name
    database: heimdall
    # -- PostgreSQL username (default: postgres)
    username: postgres
    # -- PostgreSQL password (leave empty for auto-generated, recommended)
    # To retrieve auto-generated password: kubectl get secret -n <namespace> <release>-postgresql -o jsonpath="{.data.postgres-password}" | base64 -d
    # Note: Do NOT use existingSecret - it has known issues with Bitnami chart
    password: ""

  ## Primary database configuration
  primary:
    ## Service configuration
    service:
      # -- PostgreSQL service port
      ports:
        postgresql: 5432

    ## Persistence configuration
    persistence:
      # -- Enable persistent storage for PostgreSQL data
      enabled: true
      # -- Size of persistent volume claim
      size: 10Gi
      # -- Storage class for PVC (leave empty for default)
      storageClass: ""

    ## Resource limits and requests
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 200m
        memory: 256Mi

# ===========================================================================
# External Database Configuration
# ===========================================================================
# Use when postgresql.enabled=false
# Supports AWS RDS, Google Cloud SQL, Azure Database, or self-hosted PostgreSQL
externalDatabase:
  # -- External PostgreSQL hostname (e.g., heimdall-db.abc123.us-east-1.rds.amazonaws.com)
  host: ""
  # -- External PostgreSQL port
  port: 5432
  # -- External database name
  database: heimdall
  # -- External database username
  username: postgres
  # -- Existing secret containing database password
  # Secret must have key matching existingSecretPasswordKey
  existingSecret: ""
  # -- Key in existingSecret that contains the password
  existingSecretPasswordKey: "password" 

certs:
  enabled: false # Using this allows you to override the pre-baked system certs on the heimdall container.
  systemCertsApproach:
    enabled: false # If enabled, this system-certificates approach will generate a new set of system certificates with your provided certificates injected inside within an init container. Those system certificates will be overlaid on top of the Heimdall container's system certificates. If this is disabled, then the certificate that is provided will be injected into a location within the Heimdall container and will have the NODE_EXTRA_CA_CERTS and SSL_CERT_FILE environment variables pointed at it. Please note this non-system-certificates approach requires all certificates to be placed in a single .pem file. 
    image: # which image with root/sufficient privileges will be used to take the injected certs and process them into the locations that the system will be looking for
      repository: registry.access.redhat.com/ubi8/ubi # the default Heimdall image is currently built on UBI 8
      pullPolicy: Always
      tag: "latest"
    command: "['sh', '-c', 'update-ca-trust']" # RHEL style distros use the `update-ca-trust` command to update the system CA trust store
    injectedCertsMountPath: /etc/pki/ca-trust/source/anchors # the location that `update-ca-trust` looks inside for user supplied certs
    processedCertsMountPaths: [/etc/pki/ca-trust/extracted/openssl, /etc/pki/ca-trust/extracted/pem, /etc/pki/ca-trust/extracted/java, /etc/pki/ca-trust/extracted/edk2] # due to the chart using `emptyDir` (which supplies a completely blank dir) to specify the shared volumes between this container and Heimdall's, and due to `update-ca-trust` apparently requiring several subdirectories underneath /etc/pki/ca-trust/extracted to exist, we need to manually specify each subdirectory
#    securityContext: 
#      runAsNonRoot: true
#      runAsGroup: 1001
#      runAsUser: 1001
#      readOnlyRootFileSystem: false
#    resources:
#      limits:
#        cpu: 1000m
#        memory: 8Gi
#      requests:
#        cpu: 1000m
#        memory: 8Gi
#  securityContext:
#    runAsRoot: true
#  resources:
#    limits:
#      memory: "128Mi"
#      cpu: "500m"

  name: heimdall-cacerts # name of the configmap that will include all the certs' file contents
  certificates: 
    # if systemsCertsApproach is enabled, you can provide an array of certificates, otherwise, you must put all certificates into a single .pem file
    # an example way to combine the certificates is `cat cert1.crt cert2.crt > certs.pem`
    - filename: certs.pem
      contents: |
        replace with certificate file contents 

heimdall:
  image:
    repository: heimdall-app
    pullPolicy: IfNotPresent
    tag: "arm64-test"

  # ===========================================================================
  # Secrets Management (Three Approaches - Following Vulcan Pattern)
  # ===========================================================================
  # Priority: existingSecret > secrets > secretsFiles
  #
  # Approach 1: Use existing secret (Production - Recommended)
  # Use with External Secrets Operator, Sealed Secrets, or Vault
  # Example:
  #   existingSecret: "heimdall-production-secrets"
  # Required secret keys: JWT_SECRET, DATABASE_PASSWORD, ADMIN_PASSWORD
  existingSecret: ""

  # Approach 2: File-based secrets (Development - Default)
  # Loads secrets from local files (gitignored)
  # Generate with: ./generate-heimdall-secrets.sh
  # Example:
  #   secretsFiles: ["env/heimdall-secrets.yaml"]
  secretsFiles: ["env/heimdall-secrets.yaml"]

  # Approach 3: Inline secrets (CI/CD)
  # Provide secrets directly in values (use --set or environment variables)
  # Example:
  #   secrets:
  #     JWT_SECRET: "your-secret-key-128-chars"
  #     DATABASE_PASSWORD: "your-db-password"
  #     ADMIN_PASSWORD: "your-admin-password"
  secrets: {}

  # Secret resource name (only used if existingSecret is not set)
  secret:
    name: heimdall-secrets

  # ===========================================================================
  # Environment Configuration Overrides (Optional)
  # ===========================================================================
  # Override non-sensitive environment variables from env/heimdallconfig.yaml
  # Example:
  #   config:
  #     NODE_ENV: "production"
  #     MAX_FILE_UPLOAD_SIZE: "100"
  #     CLASSIFICATION_BANNER_TEXT: "UNCLASSIFIED"
  #     LDAP_ENABLED: "true"
  #     LDAP_HOST: "ldap.example.com"
  config: {}

  # ConfigMap resource name
  configmap:
    name: heimdall-config

  # ===========================================================================
  # Service Account
  # ===========================================================================
  # Service account for Heimdall pods
  serviceAccount:
    # Create service account for Heimdall pods
    create: true
    # Annotations for service account (e.g., for AWS IAM roles, GCP Workload Identity)
    annotations: {}
    # Example for AWS EKS:
    # annotations:
    #   eks.amazonaws.com/role-arn: arn:aws:iam::123456789012:role/heimdall-role
    # Name of service account (generated if empty)
    name: ""

  # ===========================================================================
  # Database Migration Job (Helm Hook)
  # ===========================================================================
  # Runs Sequelize migrations on install/upgrade before the main deployment
  # Uses Helm hooks to ensure database schema is up-to-date
  dbMigrate:
    enabled: true

    # Job behavior configuration
    backoffLimit: 3  # Retry failed migrations up to 3 times
    activeDeadlineSeconds: 300  # Kill migration job after 5 minutes

    # Migration command (default: yarn backend sequelize-cli db:migrate)
    # Override if you need custom migration logic
    command: []
    # Example custom command:
    # command:
    #   - yarn
    #   - backend
    #   - sequelize-cli
    #   - db:migrate
    #   - --env
    #   - production

    # Additional environment variables for migration job
    env: []
    # Example:
    # env:
    #   - name: SEQUELIZE_ENV
    #     value: production

    # Resource limits for migration job
    resources:
      requests:
        cpu: 100m
        memory: 256Mi
      limits:
        cpu: 500m
        memory: 512Mi

    # Security context for migration job container
    securityContext: {}
    # Example:
    #   runAsNonRoot: true
    #   runAsUser: 1000
    #   allowPrivilegeEscalation: false

    # Pod-level security context
    podSecurityContext: {}
    # Example:
    #   fsGroup: 2000
    #   runAsNonRoot: true

    # Pod annotations
    podAnnotations: {}

    # Job annotations (separate from pod annotations)
    annotations: {}

    # Node selector for migration job
    nodeSelector: {}

    # Tolerations for migration job
    tolerations: []

    # Affinity rules for migration job
    affinity: {}

    # Additional init containers (runs before wait-for-postgres)
    extraInitContainers: []
    # Example:
    # extraInitContainers:
    #   - name: download-migrations
    #     image: busybox
    #     command: ['sh', '-c', 'echo "Downloading migrations..."']

    # Volume mounts for migration job
    volumeMounts: []

    # Volumes for migration job
    volumes: []

  service:
    type: ClusterIP
    port: 3000

  ingress:
    enabled: true  
    apiVersion: networking.k8s.io/v1
    kind: Ingress

    hosts:
      - host: localhost
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: heimdall
                port:
                  number: 3000

#     annotations:
#       traefik.ingress.kubernetes.io/router.entrypoints: websecure
#       traefik.ingress.kubernetes.io/router.tls: "true"
#       traefik.ingress.kubernetes.io/service.sticky.cookie: "true"

#     className: ingress class name

#     tls:
#       - name: nginx
#         secretName: ingress-secret
#         hosts:
#           - heimdall.example.com
  
# Introducing this tag utilizes the gateway API instead of the ingress API.
# Both cannot be used at the same time.
  gateway:
    enabled: false
#    apiVersion: 
#    kind: VirtualService 
    
#    gateways:
#       List of gateways
#      hosts:
#         List of hostsnames that the gateway handles traffic for
#        - 
#      http: Route Config
#        - name: Name for the route group
#          route: 
#            - destination:
#                host: Service name within cluster
#                port: Port number of service
#                  number: 3000
#    annotations:
#       Optional annotations for the gateway

  podAnnotations: {}
#   Example:
#     imageregistry: "https://example.docker.com"

  podSecurityContext: {}
#   Example:
#     runAsUser: 1000
#     runAsGroup: 3000

  securityContext: {}
#   Example:
#    runAsUser: 1000
#    runAsGroup: 3000

  resources: {}
#    Example:
#    requests:
#      cpu: 100m
#      memory: 128Mi
#    limits:
#      cpu: 200m
#      memory: 256Mi

  nodeSelector: {}
#    Example:
#    kubernetes.io/example: linux
#    kubernetes.io/example: amd64

  tolerations: []
#    Example:
#    - key: "node-role.kubernetes.io/example"
#      operator: "Exists"
#      effect: "NoSchedule"

  affinity: {}

  livenessProbe:
    httpGet:
      path: /
      port: 3000
    initialDelaySeconds: 80
    periodSeconds: 10
    timeoutSeconds: 15
    failureThreshold: 3

  readinessProbe:
    httpGet:
      path: /
      port: 3000
    initialDelaySeconds: 80
    periodSeconds: 10
    timeoutSeconds: 15
    failureThreshold: 3

  imagePullSecrets: []
#     - name: your-secret-name
