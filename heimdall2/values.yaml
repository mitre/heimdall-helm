## Please see the following for explanations on many of the Heimdall specific envvars:
# https://github.com/mitre/heimdall2/wiki/Environment-Variables-Configuration
# apps/backend/.env-example

# classificationBannerText: default is no banner
# classificationBannerTextColor: default white
# classificationBannerColor: default red

nodeEnv: production

# adminEmail: default admin@heimdall.local
# adminUsesExternalAuth: default false
# adminPassword: default autogenerated (CHECK THE LOGS TO FIND IT)

# localLoginDisabled: default false
# registrationDisabled: default false
# oneSessionPerUser: default false
## Generate the following via `openssl rand -hex 64` and set
# jwtSecret: long-random-string-of-text
## Set `1d` or `25m`
# jwtExpireTime: 25m

## Generate the following via `openssl rand -hex 33` and set
# apiKeySecret: different-long-random-string-of-text
# maxFileUploadSize: size-in-megabytes (default 50)

## Set FDQN for external database host or set `postgresql.enabled` equal to `true`
# databaseHost: postgresql.example.com
## Set external database port or set `postgresql.enabled` equal to `true`
# databasePort: 5672
databaseName: heimdall-database
databaseUsername: postgres
## Set postgres user's password via `openssl rand -hex 33`
# databasePassword: long-random-string-of-text
# databaseSsl: default false
# databaseSslInsecure: default false
# databaseSslKey: path-or-raw-key # Must be set if using SSL
# databaseSslCert: path-or-raw-cert # Must be set if using SSL
# databaseSslCa: path-or-raw-ca # Must be set if using SSL

# externalUrl: 'public'/externally facing URL for your deployment (ex. for use in callback urls for auth integrations) # Must be set

# splunkHostUrl: default empty string (ex. https://your.splunk.domain.com)
# tenableHostUrl: default empty string (ex. https://your.tenable.domain.com)
# forceTenableFrontend: default false (If true, the frontend will use Tenable.SC Lite features

# ldapEnabled: default false
# ldapHost: url # Must be set if using LDAP 
# ldapPort: default 389
# ldapBindDn: Dn of user used for lookups # Must be set if using LDAP
# ldapPassword: user's password # Must be set if using LDAP
# ldapSearchBase: ex. "OU=Users, DC=<yourdomain>, DC=local" # Must be set if using LDAP 
# ldapSearchFilter: ex. "sAMAccountName={{username}}"  
# ldapNameField: default name
# ldapMailField: default mail
# ldapSsl: default false
# ldapSslInsecure: default false
# ldapSslCa: path-or-raw-ca

# googleClientId: value-from-google # Must be set if using Google login
# googleClientSecret: value-from-google # Must be set if using Google login

# githubClientId: value-from-github # Must be set if using GitHub login
# githubClientSecret: value-from-github # Must be set if using GitHub login
# githubEnterpriseInstanceBaseUrl: default https://github.com/
# githubEnterpriseInstanceApiUrl: default https://api.github.com/

# gitlabClientId: value-from-gitlab # Must be set if using GitLab login
# gitlabClientSecret: value-from-gitlab # Must be set if using GitLab login
# gitlabBaseUrl: default https://gitlab.com/

# httpsProxy: # example http://my.proxy.com:8000. (No default)

# oktaDomain: yourdomain.okta.com # Your assigned Okta domain (No default, if using Okta login either this variable or OKTA_ISSUER, OKTA_AUTHORIZATION_URL, OKTA_TOKEN_URL, and OKTA_USER_INFO_URL must be set)
# oktaClientId: value-from-okta # No default, must be set if using Okta login
# oktaClientSecret: value-from-okta # Your application's client secret (No default, must be set if using Okta login)
# oktaIssuer: okta-base-url # example: https://domain.octa.com No default, if using Okta login either OKTA_AUTHORIZATION_URL, OKTA_TOKEN_URL, OKTA_USER_INFO_URL, and this variable or OKTA_DOMAIN must be set
# oktaAuthorizationUrl: okta-authorization-endpoint # example: https://domain.octa.com/oauth2/v1/authorize No default, if using Okta login either OKTA_ISSUER, OKTA_TOKEN_URL, OKTA_USER_INFO_URL, and this variable or OKTA_DOMAIN must be set
# oktaTokenUrl: okta-token-endpoint # No default, if using Okta login either OKTA_ISSUER, OKTA_AUTHORIZATION_URL, OKTA_USER_INFO_URL, and this variable or OKTA_DOMAIN must be set
# oktaUserInfoUrl: value-from-okta # No default, if using Okta login either OKTA_ISSUER, OKTA_AUTHORIZATION_URL, OKTA_TOKEN_URL, and this variable or OKTA_DOMAIN must be set
# oktaUseHttpsProxy: # Default false, requires the `HTTPS_PROXY` envvar also being set

# oidcName: frontend-name # No default, must be set if using OIDC login
# oidcIssuer: base-url # example: https://sample.us.auth0.com No default, must be set if using OIDC login
# oidcAuthorizationUrl: auth-endpoint # example: https://sample.us.auth0.com/authorize No default, must be set if using OIDC login
# oidcTokenUrl: token-endpoint # example: https://sample.us.auth0.com/oauth/token No default, must be set if using OIDC login
# oidcUserInfoUrl: info-endpoint # example: https://sample.us.auth0.com/userinfo No default, must be set if using OIDC login
# oidcClientId: value-from-oidc # No default, must be set if using OIDC login
# oidcClientSecret: value-from-oidc # No default, must be set if using OIDC login
# oidcExternalGroups: # Default false
# oidcUsesPKCES256: # Default false, must be set if using PKCE, must not be set if you want to use the plain code challenge method
# oidcUsesPKCEPlain: # Default false, must be set if using PKCE, must not be set if you want to use the S256 code challenge method
# oidcUseHttpsProxy: # Default false, requires the HTTPS_PROXY envvar also being set

# In order to use sops, set enable to true, make sure the name of the external secret is the same as the internal secret, default: heimdall2
sops:
  enabled: false
  secrets: []
    # Populate this array with with all secrets you want encrypted in the SOPS pod
    # Example
    # - DATABASE_PASSWORD
    # - DATABASE_USERNAME
    # - ADMIN_PASSWORD
    # - JWT_SECRET
    # - API_KEY_SECRET

postgresql:
  enabled: true

  image:
    repository: postgres
    pullPolicy: Always
    tag: "13"

  persistence:
  #   Volume used to store the Heimdall's data.
    enabled: false
    size: "100Mi"
  #   Sets persistent volume claim's storageClassName.
    storageClassName: "default"
    accessMode: "ReadWriteOnce"

  service:
    type: ClusterIP
    port: 5672

  podAnnotations: {} 
#   Example:
#     imageregistry: "https://example.docker.com"

  podSecurityContext: {} 
#   Example:
#     runAsUser: 1000
#     runAsGroup: 3000

  securityContext: {} 
#   Example:
#     runAsUser: 1000
#     runAsGroup: 3000
#     runAsNonRoot: true

  resources: {} 
#   Example:
#     requests:
#       cpu: 100m
#       memory: 128Mi
#     limits:
#       cpu: 200m
#       memory: 256Mi

  nodeSelector: {} 
#   Example:
#     kubernetes.io/example: linux
#     kubernetes.io/example: amd64

  tolerations: [] 
#   Example:
#     - key: "node-role.kubernetes.io/example"
#       operator: "Exists"
#       effect: "NoSchedule"

  affinity: {} 

certs:
  enabled: false
  systemCertsApproach:
    enabled: false
    image: # which image with root/sufficient privileges will be used to take the injected certs and process them into the locations that the system will be looking for
      repository: registry.access.redhat.com/ubi8/ubi # the default Heimdall image is currently built on UBI 8
      pullPolicy: Always
      tag: "latest"
    command: "['sh', '-c', 'update-ca-trust']" # RHEL style distros use the `update-ca-trust` command to update the system CA trust store
    injectedCertsMountPath: /etc/pki/ca-trust/source/anchors # the location that `update-ca-trust` looks inside for user supplied certs
    processedCertsMountPaths: [/etc/pki/ca-trust/extracted/openssl, /etc/pki/ca-trust/extracted/pem, /etc/pki/ca-trust/extracted/java, /etc/pki/ca-trust/extracted/edk2] # due to the chart using `emptyDir` (which supplies a completely blank dir) to specify the shared volumes between this container and Heimdall's, and due to `update-ca-trust` apparently requiring several subdirectories underneath /etc/pki/ca-trust/extracted to exist, we need to manually specify each subdirectory
#     securityContext: {}
#     runAsRoot: false
#     resources:
#       limits:
#         memory: "128Mi"
#         cpu: "500m"
  name: heimdall-cacerts # name of the configmap that will include all the certs' file contents
  certificates: 
    # if systemsCertsApproach is enabled, you can provide an array of certificates, otherwise, you must put all certificates into a single .pem file
    # an example way to combine the certificates is `cat cert1.crt cert2.crt > certs.pem`
    - filename: certs.pem
      contents: |
        replace with certificates

heimdall:
  image:
    repository: mitre/heimdall2
    pullPolicy: Always
    tag: "release-latest"

  service:
    type: ClusterIP
    port: 3000

  ingress:
    enabled: true  
    apiVersion: networking.k8s.io/v1
    kind: Ingress

    hosts:
      - host: localhost
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: heimdall
                port:
                  number: 3000

#     annotations:
#       traefik.ingress.kubernetes.io/router.entrypoints: websecure
#       traefik.ingress.kubernetes.io/router.tls: "true"
#       traefik.ingress.kubernetes.io/service.sticky.cookie: "true"

#     className: ingress class name

#     tls:
#       - name: nginx
#         secretName: ingress-secret
#         hosts:
#           - heimdall.example.com
  
# Introducing this tag utilizes the gateway API instead of the ingress API.
# Both cannot be used at the same time.
  gateway:
    enabled: false
#    apiVersion: 
#    kind: VirtualService 
    
#    gateways:
#       List of gateways
#      hosts:
#         List of hostsnames that the gateway handles traffic for
#        - 
#      http: Route Config
#        - name: Name for the route group
#          route: 
#            - destination:
#                host: Service name within cluster
#                port: Port number of service
#                  number: 3000
#    annotations:
#       Optional annotations for the gateway

  podAnnotations: {}
#   Example:
#     imageregistry: "https://example.docker.com"

  podSecurityContext: {}
#   Example:
#     runAsUser: 1000
#     runAsGroup: 3000

  securityContext: {}
#   Example:
#    runAsUser: 1000
#    runAsGroup: 3000

  resources: {}
#    Example:
#    requests:
#      cpu: 100m
#      memory: 128Mi
#    limits:
#      cpu: 200m
#      memory: 256Mi

  nodeSelector: {}
#    Example:
#    kubernetes.io/example: linux
#    kubernetes.io/example: amd64

  tolerations: []
#    Example:
#    - key: "node-role.kubernetes.io/example"
#      operator: "Exists"
#      effect: "NoSchedule"

  affinity: {}

  livenessProbe:
    httpGet:
      path: /
      port: 3000
    initialDelaySeconds: 80
    periodSeconds: 10
    timeoutSeconds: 15
    failureThreshold: 3

  readinessProbe:
    httpGet:
      path: /
      port: 3000
    initialDelaySeconds: 80
    periodSeconds: 10
    timeoutSeconds: 15
    failureThreshold: 3

  imagePullSecrets:
#     - name: your-secret-name